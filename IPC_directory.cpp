/*Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.*/

#include <cstdlib>
#include <deque>
#include <iostream>
#include <list>
#include <memory>
#include <set>
#include <utility>
#include <boost/asio.hpp>
#include <boost/array.hpp>
#include <boost/lexical_cast.hpp>
#include "message.hpp"

/** README
    A sample interprocess communication server that accepts tcp clients and 
    provides message flow across clients asynchronously.
    # Can start multiple servers with multiple ports.
    # Each server accepts multiple clients
    # Each client can communicate either in same server or across different
      servers. Each client has a unique client ID.
    # To communicate to a client it needs to identify it with a client ID 
    # To send a message across client prompts use | 'pipe' separated by 
      messsage
       For eg. "client_id|Message to client" - "2|Hello world message."
    
    [Shell prompt]# ./ipc_server.exe  [port1] [port2] ...
    #./ipc_server.exe 2233
**/

using boost::asio::ip::tcp;

class ipc_server;
class message_handler;
class IPC_directory;


//----------------------------------------------------------------------

class observer_board  {
  private:
    IPC_directory& dir;
    std::map<int, ipc_server&> ipc_observer;
    std::map<int, message_handler&> msg_observer;
  public:
    observer_board(IPC_directory& dir) : dir(dir){}
    void register_ipc_server(ipc_server& ipc_serv);
    void execute_command_msg_hdl(int client_id, const std::string& msg);
    void set_message_handler(message_handler& msg);
    void update_observer(int client_id);
    std::list<int> connected_clients();
};

//----------------------------------------------------------------------

int parse_message(const std::string& str) {
  std::size_t pos = str.find("|");
  std::string str_msg;
  std::string str_ps_name;
  if (pos != std::string::npos) {
    str_msg = str.substr(pos+1);
    str_ps_name = str.substr(0, pos);
  } else {
    str_msg = str;
  }
  int ipc_no = atoi((str_ps_name).data());
  return ipc_no;
}

//-------------------------------------------------------------------

class message_handler
{
public:
  message_handler(tcp::socket socket, int id, observer_board& ob) : 
         socket_(std::move(socket)), client_id(id), ob(ob) {
    handle_socket_session();
    welcome_message();
  }

  void handle_socket_session();
  void delivery(const std::string& );
  void read_header();
  void read_body();
  void write_message_socket(const std::string&);
  void welcome_message();

  int get_client_id() { return client_id; }

private:
  tcp::socket socket_;
  message read_msg_;  
  std::deque<std::string> message_queue;
  observer_board& ob;
  int client_id;
};

void message_handler::welcome_message() {
    std::string str("Connected to server, client id# - ");
    str.append(std::to_string(client_id));
    str.append(" - Welcome to Directory, present ids# of clients are: ");
    std::list<int> connected_client = ob.connected_clients();
    if ( connected_client.size() == 0 ) {
        str.append(" None ");
    } else {
        std::stringstream result;
        std::copy(connected_client.begin(), connected_client.end(), 
                                    std::ostream_iterator<int>(result, " "));
        std::string clients(result.str().c_str());
        str.append(clients);
    }
    write_message_socket(str);
}
void message_handler::write_message_socket(const std::string& str) {
  message msg;
  msg.body_length(std::strlen(str.data()));
  std::memcpy(msg.body(), str.data(), msg.body_length());
  msg.encode_header();
  boost::asio::async_write(socket_, boost::asio::buffer(msg.data(),msg.length()),
      [this](boost::system::error_code ec, std::size_t /*length*/) {
        if (!ec) {
          //TODO Update Success
        } else {
            //TODO failure
        }          

      }
  );
}


void message_handler::delivery(const std::string&  msg) {
    int ipcno = -1;
    ipcno = parse_message(msg);
    if ( ipcno != -1 ) {
        // TODO Find the ipc_name from observer and execute_to_ipc_name
        ob.execute_command_msg_hdl(ipcno, msg);
    } else {
        write_message_socket(msg);
    }
    
}
void message_handler::handle_socket_session() {
  read_header();
}

void message_handler::read_header() {
  memset(read_msg_.data(), '\0', read_msg_.length());
  boost::asio::async_read(socket_,
      boost::asio::buffer(read_msg_.data(), message::header_size_),
      [this](boost::system::error_code ec, std::size_t) {
        if (!ec && read_msg_.decode_header()) { 
          read_body();
        } else {
            std::cout << "Error Reading message body " << ec << std::endl;
            //TODO Update the remove handler from list at EOF of disconnect
            ob.update_observer(client_id);
        }
      }
  );
}

void message_handler::read_body() {
  memset(read_msg_.data(), '\0', read_msg_.length());
  boost::asio::async_read(socket_,
      boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),
      [this](boost::system::error_code ec, std::size_t /*length*/) {
        if (!ec) {
          delivery(read_msg_.body());
          read_header();
        } else {
            std::cout << "Error Reading messge body " << ec << std::endl;
            //TODO Update the remove handler from list at EOF of disconnect
            ob.update_observer(client_id);
        }
      }
  );
}

//-------------------------------------------------------------------

class ipc_server 
{
public:
  ipc_server(boost::asio::io_service& io_service, const tcp::endpoint& endpoint, 
        observer_board& ob, int ipc_server_id) : io_service(io_service), 
        acceptor_(io_service, endpoint), socket_(io_service), ob(ob), ipc_server_id(ipc_server_id) {
    accept_incoming_socket();
  }

  int get_ipc_server_id() {
    return ipc_server_id;
  }


private:
  void accept_incoming_socket() {
    acceptor_.async_accept(socket_, [this](boost::system::error_code ec) {
          if (!ec) {  
            message_handlers.emplace_back(std::move(socket_), ++client_id, ob);
            message_handler& msg = message_handlers.back();
            ob.set_message_handler(msg);
          }
          accept_incoming_socket();
        }
    );
  }


  std::list<message_handler> message_handlers;
  boost::asio::io_service& io_service;
  tcp::acceptor acceptor_;
  tcp::socket socket_;
  int ipc_server_id;
  observer_board& ob;
public:
  static int client_id;
};
int ipc_server::client_id = 0;


//--------------------------------------------------------------------

class IPC_directory {
    private:
        std::list<ipc_server> ipc_servers;
    public:
        IPC_directory(){};
        void create_ipc_server(boost::asio::io_service& io_service, 
                    tcp::endpoint& endpoint, observer_board& ob, int i);
        std::list<ipc_server>& get_ipc_servers() {
          return ipc_servers;
        }
};

void IPC_directory::create_ipc_server(boost::asio::io_service& io_service, 
            tcp::endpoint& endpoint, observer_board& ob, int ipc_server_id) {
    std::cout << "TCP Endpoint " << endpoint << std::endl;
    ipc_servers.emplace_back(io_service, endpoint, ob, ipc_server_id);
}

//-------------------------------------------------------------------


void observer_board::register_ipc_server(ipc_server& ipc_serv) {
  ipc_observer.emplace(ipc_serv.get_ipc_server_id(), ipc_serv);
}

void observer_board::set_message_handler(message_handler& msg) {
    msg_observer.emplace(msg.get_client_id(), msg);
}

void observer_board::execute_command_msg_hdl(int client_id, const std::string& mesg) {
    auto itr = msg_observer.find(client_id);
    if (itr!= msg_observer.end() ) {
        message_handler& msg_hdl = (itr->second);
        msg_hdl.write_message_socket(mesg);
    }
}

void observer_board::update_observer(int client_id) {
    auto itr = msg_observer.find(client_id);
    msg_observer.erase(itr);
}

std::list<int> observer_board::connected_clients() {
    std::list<int> clis;
    for (auto itr : msg_observer) {
        clis.push_back(itr.first);
    }
    return clis;
}


//-------------------------------------------------------------------


int main (int argc, char* argv[])
{
  try {
    if (argc < 2) {
      std::cerr << "Usage: chat_server <port> [<port> ...]\n";
      return 1;
    }
    boost::asio::io_service io_service;
    IPC_directory ipc_dir;
    observer_board broadcaster(ipc_dir);

    std::cout << "TRACE IN IPC_directory.start_directory_server" << std::endl;

    for (int i = 1; i < argc; ++i) {
      tcp::endpoint endpoint(tcp::v4(), std::atoi(argv[i]));
      ipc_dir.create_ipc_server(io_service, endpoint, broadcaster, i);
    }
    for (auto it = ipc_dir.get_ipc_servers().begin(); it!=ipc_dir.get_ipc_servers().end(); ++it) {
      broadcaster.register_ipc_server(*it);
    }
    std::cout << "TRACE OUT IPC_directory.start_directory_server" << std::endl;

    io_service.run();

  }
  catch (std::exception& e) {
    std::cerr << "Exception: " << e.what() << "\n";
  }

    return 0;
}
